信号默认的五种行为：
终止
终止 core
忽略
暂停
继续:

信号产生的三种方式：
用户输入    ctrl+c ctrl+\
内核产生    异常时
kill


---------------------------------

多线程
cat /etc/proc/task

一个进程中的所有线程共享一个地址空间
线程唯一私有的是线程控制表

exit()  慎重

nptl线程库(当前学习的是这种)
nptl的所有接口都不能使用perro，因为他们没改变erronum这个错误码

只有一个线程，但是同时执行多道执行流-》协程

main线程退出后才回收资源，main线程要最后退出
除了其他线程不能等main线程外，任意线程之间可以等待


子线程可能会打印两次                                                                                             
因为子线程并不是边输出边清空，而是输出玩之后再清空
在子线程输出完成后，此时主线程关闭标准输出会再刷新缓存区，因此有两次

进程里面每一个地址对于所有线程读写权限是一样的，因此，虽然各线程栈空间私有但是其他线程仍然可以访问


指针变可以存地址，还可以这样用：
void* p = (void*)1;     //其实就相当于指针变量中存了一个整数
printf("%ld \n", (long)p);

pthread_join中第二个参数是二级指针的原因是该参数为传出参数，它要存储threadfunc的返回值（为一级指针）
要改变一个一级指针值，函数中要对其取地址才能修改

11:32 常用法

线程清理函数

二级指针和long？


线程的取消

子线cancel成功返回-1

会执行线程清理函数的几种情况:
1，pthread_cancel，子线程走到cancel点
2，pthread_exit
3，pthread_cleanup_pop(1)
        为0时为弹栈不执行

一个线程加了锁，另一个线程可以直接解除掉的，只是一般不会有这种写法
锁是一种资源，加减锁实际是对这个变量的读写操作
所以像信号量那里，这里也可以解锁

睡眠锁
自旋锁

读写锁
写的时候要确保读锁都解开

可以设置锁的属性，加锁多次，但是也要解锁多次其他线程才能用（其他线程可以自己解锁，但是是伪需求很奇怪，一般自己加的自己解）

线程同步
条件变量
