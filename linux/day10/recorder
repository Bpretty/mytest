munmap  可以分多次解除映射，但是每次必须是4k的整数倍



信号
传递一种行为

kill -l     查看所有信号(-l是字母不是数字   )
kill -2 pid 给pid发送2号信号

有两个信号既不能被捕捉也不能被忽略，他们是 SIGKILL SIGSTOP。收到这两个信号只能接受系统默认处理

相同信号不会打断自身的处理流程,不同信号会打断对方的处理流程
相同信号多次发送，再多执行一次(因为内核中使用的是集合而不是队列)

        一个特殊例子: 先2号信号，再3号信号，再2号信号
        执行效果为: 
                2 is comming
                3 is comming
                3 is comming
        可以理解为最外层还是在2号的圈内，符合第一条原则所以再发2号打断不了流程

响应信号跟进程状态无关，是否睡觉不影响
    可以监控2/3号信号，再读取标准输入进行测试

echo $?     查看的是上一个进程的返回值

signal
信号下一次设置的行为可以把上一次覆盖掉

sigaction信号处理
如果函数执行系统调用(如read)，发生了一个信号，sigaction默认跳转到系统调用之后执行(也可以设置卡在那个位置)
sa_flags掩码值含义(位权限):
SA_RESETHAND    处理完毕要捕捉的信号后自动撤销处理函数的注册
SA_NODEFER      不断重入，信号不丢失(其他信号进入中的其他，包含自己)
SA_RESTAT       发生信号时，如果程序阻塞在某个系统调用，如read函数，则在处理完信号后接着从阻塞的系统返回。如果不指定该参数，中断处理完后，read读取失败
SA_SIGINFO      指定那个信号处理函数指针有效，如果sa_flags包含该掩码则sa_sigaction指针有效，否则sa_handler指针有效    

sigpending  获取被阻塞的信号集，已经响应或者被忽略的是拿不到的

使用全局变量的结构体类型给信号处理函数传参

sigprocmask
用来保护关键代码段不被信号打断
阻塞的优先级是高于忽略的优先级的
    可通过查看pending中的信号与返回值验证

发送信号
kill

计时器:todo



